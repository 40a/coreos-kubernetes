#cloud-config

coreos:
  update:
    reboot-strategy: "off"

  flannel:
    interface: $private_ipv4
    etcd_endpoints: {{ETCD_ENDPOINTS}}

  units:
  - name: bootstrap.service
    command: start
    content: |
      [Service]
      ExecStart=/bin/bash -e /tmp/bootstrap.sh
      Type=oneshot

      EnvironmentFile=-/etc/kube-bootstrap-env

write_files:
- path: /tmp/bootstrap.sh
  content: |
    /bin/bash /tmp/worker.sh init
    /bin/bash /tmp/worker.sh start

- path: /tmp/worker.sh
  content: |
    #!/bin/bash -e

    function usage {
        echo "USAGE: $0 <command>"
        echo "Commands:"
        echo -e "\tinit \tInitialize worker node services"
        echo -e "\tstart \tStart worker node services"
    }

    if [ -z $1 ]; then
        usage
        exit 1
    fi

    CMD=$1

    function init_config {
        local REQUIRED=( 'ADVERTISE_IP' 'ETCD_ENDPOINTS' 'CONTROLLER_ENDPOINT' 'DNS_SERVICE_IP' 'K8S_VER' )

        if [ -z $K8S_VER ]; then
            export K8S_VER=v1.0.3
        fi
        if [ -z $ADVERTISE_IP ]; then
            export ADVERTISE_IP=$(awk -F= '/COREOS_PUBLIC_IPV4/ {print $2}' /etc/environment)
        fi
        if [ -z $ETCD_ENDPOINTS ]; then
            export ETCD_ENDPOINTS="http://127.0.0.1:2379"
        fi
        if [ -z $CONTROLLER_ENDPOINT ]; then
            export CONTROLLER_ENDPOINT="http://127.0.0.1:8080"
        fi
        if [ -z $DNS_SERVICE_IP ]; then
            export DNS_SERVICE_IP="10.3.0.10"
        fi

        for REQ in "${REQUIRED[@]}"; do
            if [ -z "$(eval echo \$$REQ)" ]; then
                echo "Missing required config value: ${REQ}"
                exit 1
            fi
        done
    }

    function init_docker {
        local TEMPLATE=/etc/systemd/system/docker.service.d/40-flannel.conf
        [ -f $TEMPLATE ] || {
            echo "TEMPLATE: $TEMPLATE"
            mkdir -p $(dirname $TEMPLATE)
            cat << EOF > $TEMPLATE
    [Unit]
    Requires=flanneld.service
    After=flanneld.service
    EOF
        }

        # reload now before docker commands are run in later
        # init steps or dockerd will start before flanneld
        systemctl daemon-reload
    }

    function init_templates {
        local TEMPLATE=/etc/systemd/system/kubelet.service
        [ -f $TEMPLATE ] || {
            echo "TEMPLATE: $TEMPLATE"
            mkdir -p $(dirname $TEMPLATE)
            cat << EOF > $TEMPLATE
    [Service]
    ExecStartPre=/usr/bin/mkdir -p /etc/kubernetes/manifests
    ExecStart=/usr/bin/kubelet \
      --api_servers=${CONTROLLER_ENDPOINT} \
      --register-node=true \
      --allow-privileged=true \
      --config=/etc/kubernetes/manifests \
      --hostname-override=${ADVERTISE_IP} \
      --cluster_dns=${DNS_SERVICE_IP} \
      --cluster_domain=cluster.local \
      --kubeconfig=/etc/kubernetes/worker-kubeconfig.yaml \
      --tls-cert-file=/etc/kubernetes/ssl/worker.pem \
      --tls-private-key-file=/etc/kubernetes/ssl/worker-key.pem \
      --cadvisor-port=0
    Restart=always
    RestartSec=10
    [Install]
    WantedBy=multi-user.target
    EOF
        }

        local TEMPLATE=/etc/kubernetes/worker-kubeconfig.yaml
        [ -f $TEMPLATE ] || {
            echo "TEMPLATE: $TEMPLATE"
            mkdir -p $(dirname $TEMPLATE)
            cat << EOF > $TEMPLATE
    apiVersion: v1
    kind: Config
    clusters:
    - name: local
      cluster:
        certificate-authority: /etc/kubernetes/ssl/ca.pem
    users:
    - name: kubelet
      user:
        client-certificate: /etc/kubernetes/ssl/worker.pem
        client-key: /etc/kubernetes/ssl/worker-key.pem
    contexts:
    - context:
        cluster: local
        user: kubelet
      name: kubelet-context
    current-context: kubelet-context
    EOF
        }

        local TEMPLATE=/etc/kubernetes/manifests/kube-proxy.yaml
        [ -f $TEMPLATE ] || {
            echo "TEMPLATE: $TEMPLATE"
            mkdir -p $(dirname $TEMPLATE)
            cat << EOF > $TEMPLATE
    apiVersion: v1
    kind: Pod
    metadata:
      name: kube-proxy
      namespace: kube-system
    spec:
      hostNetwork: true
      containers:
      - name: kube-proxy
        image: gcr.io/google_containers/hyperkube:$K8S_VER
        command:
        - /hyperkube
        - proxy
        - --master=${CONTROLLER_ENDPOINT}
        - --kubeconfig=/etc/kubernetes/worker-kubeconfig.yaml
        securityContext:
          privileged: true
        volumeMounts:
          - mountPath: /etc/ssl/certs
            name: "ssl-certs"
          - mountPath: /etc/kubernetes/worker-kubeconfig.yaml
            name: "kubeconfig"
            readOnly: true
          - mountPath: /etc/kubernetes/ssl
            name: "etc-kube-ssl"
            readOnly: true
      volumes:
        - name: "ssl-certs"
          hostPath:
            path: "/usr/share/ca-certificates"
        - name: "kubeconfig"
          hostPath:
            path: "/etc/kubernetes/worker-kubeconfig.yaml"
        - name: "etc-kube-ssl"
          hostPath:
            path: "/etc/kubernetes/ssl"
    EOF
        }
    }

    if [ "$CMD" == "init" ]; then
        echo "Starting initialization"
        init_config
        init_docker
        init_templates
        echo "Initialization complete"
        exit 0
    fi

    if [ "$CMD" == "start" ]; then
        echo "Starting services"
        systemctl daemon-reload
        systemctl enable kubelet; systemctl start kubelet
        echo "Service start complete"
        exit 0
    fi

    usage
    exit 1

