#cloud-config

coreos:
  update:
    reboot-strategy: "off"

  flannel:
    interface: $private_ipv4
    etcd_endpoints: {{ETCD_ENDPOINTS}}

  units:
  - name: bootstrap.service
    command: start
    content: |
      [Service]
      ExecStart=/bin/bash -e /tmp/bootstrap.sh
      Type=oneshot

      # List of etcd servers (http://ip:port), comma separated
      Environment=ETCD_ENDPOINTS={{ETCD_ENDPOINTS}}

      # Specify the version (vX.Y.Z) of Kubernetes assets to deploy
      # If left blank, the same version as the host's kubelet will be used.
      #Environment=K8S_VER=v1.0.X

      # The CIDR network to use for pod IPs.
      # Each pod launched in the cluster will be assigned an IP out of this range.
      # Each node will be configured such that these IPs will be routable using the flannel overlay network.
      #Environment=POD_NETWORK=10.2.0.0/16

      # The CIDR network to use for service cluster IPs.
      # Each service will be assigned a cluster IP out of this range.
      # This must not overlap with any IP ranges assigned to the POD_NETWORK, or other existing network infrastructure.
      # Routing to these IPs is handled by a proxy service local to each node, and are not required to be routable between nodes.
      #Environment=SERVICE_IP_RANGE=10.3.0.0/24

      # The IP address of the Kubernetes API Service
      # If the SERVICE_IP_RANGE is changed above, this must be set to the first IP in that range.
      #Environment=K8S_SERVICE_IP=10.3.0.1

      # The IP address of the cluster DNS service.
      # This IP must be in the range of the SERVICE_IP_RANGE and cannot be the first IP in the range.
      # This same IP must be configured on all worker nodes to enable DNS service discovery.
      #Environment=DNS_SERVICE_IP=10.3.0.10

      # The above settings can optionally be overridden using an environment file:
      EnvironmentFile=-/tmp/kube-bootstrap-env

write_files:
- path: /tmp/bootstrap.sh
  content: |
    /bin/bash /tmp/controller.sh init
    /bin/bash /tmp/controller.sh start

- path: /tmp/controller.sh
  content: |
    #!/bin/bash -e

    function usage {
        echo "USAGE: $0 <command>"
        echo "Commands:"
        echo -e "\tinit \tInitialize control node services"
        echo -e "\tstart \tStart control node services"
    }

    if [ -z $1 ]; then
        usage
        exit 1
    fi

    CMD=$1

    # Sanity check kubelet is available (missing will exit with set -e)
    which kubelet

    KUBELET_VER=$(kubelet --version | cut -d ' ' -f 2 | sed 's/\(v[0-9]\.[0-9]\.[0-9]\).*$/\1/')

    if [ -z "$K8S_VER" ]; then
        K8S_VER=$KUBELET_VER
    fi

    if [ "$K8S_VER" != "$KUBELET_VER" ]; then
        echo "WARNING: Kubernetes version mismatch. KUBELET_VER=$KUBELET_VER K8S_VER=$K8S_VER"
    fi

    function init_config {
        local REQUIRED=('ADVERTISE_IP' 'POD_NETWORK' 'ETCD_ENDPOINTS' 'SERVICE_IP_RANGE' 'K8S_SERVICE_IP' 'DNS_SERVICE_IP' )

        if [ -z $ADVERTISE_IP ]; then
            export ADVERTISE_IP=$(awk -F= '/COREOS_PUBLIC_IPV4/ {print $2}' /etc/environment)
        fi
        if [ -z $POD_NETWORK ]; then
            export POD_NETWORK="10.2.0.0/16"
        fi
        if [ -z $ETCD_ENDPOINTS ]; then
            export ETCD_ENDPOINTS="http://127.0.0.1:2379"
        fi
        if [ -z $SERVICE_IP_RANGE ]; then
            export SERVICE_IP_RANGE="10.3.0.0/24"
        fi
        if [ -z $K8S_SERVICE_IP ]; then
            export K8S_SERVICE_IP="10.3.0.1"
        fi
        if [ -z $DNS_SERVICE_IP ]; then
            export DNS_SERVICE_IP="10.3.0.10"
        fi
        for REQ in "${REQUIRED[@]}"; do
            if [ -z "$(eval echo \$$REQ)" ]; then
                echo "Missing required config value: ${REQ}"
                exit 1
            fi
        done
    }

    function init_flannel {
        echo "Waiting for etcd..."
        while true
        do
            IFS=',' read -ra ES <<< "$ETCD_ENDPOINTS"
            for ETCD in "${ES[@]}"; do
                echo "Trying: $ETCD"
                if [ -n "$(curl --silent "$ETCD/v2/machines")" ]; then
                    local ACTIVE_ETCD=$ETCD
                    break
                fi
                sleep 1
            done
            if [ -n "$ACTIVE_ETCD" ]; then
                break
            fi
        done
        RES=$(curl --silent -X PUT -d "value={\"Network\":\"$POD_NETWORK\"}" "$ACTIVE_ETCD/v2/keys/coreos.com/network/config?prevExist=false")
        if [ -z "$(echo $RES | grep '"action":"create"')" ] && [ -z "$(echo $RES | grep 'Key already exists')" ]; then
            echo "Unexpected error configuring flannel pod network: $RES"
        fi
    }

    function init_docker {
        local TEMPLATE=/etc/systemd/system/docker.service.d/40-flannel.conf
        [ -f $TEMPLATE ] || {
            echo "TEMPLATE: $TEMPLATE"
            mkdir -p $(dirname $TEMPLATE)
            cat << EOF > $TEMPLATE
    [Unit]
    Requires=flanneld.service
    After=flanneld.service
    EOF
        }

        # reload now before docker commands are run in later
        # init steps or dockerd will start before flanneld
        systemctl daemon-reload
    }

    function init_templates {
        local TEMPLATE=/etc/systemd/system/kubelet.service
        [ -f $TEMPLATE ] || {
            echo "TEMPLATE: $TEMPLATE"
            mkdir -p $(dirname $TEMPLATE)
            cat << EOF > $TEMPLATE
    [Service]
    ExecStartPre=/usr/bin/mkdir -p /etc/kubernetes/manifests
    ExecStart=/usr/bin/kubelet \
      --api_servers=http://127.0.0.1:8080 \
      --register-node=false \
      --allow-privileged=true \
      --config=/etc/kubernetes/manifests \
      --hostname-override=${ADVERTISE_IP} \
      --cluster_dns=${DNS_SERVICE_IP} \
      --cluster_domain=cluster.local \
      --cadvisor-port=0
    Restart=always
    RestartSec=10

    [Install]
    WantedBy=multi-user.target
    EOF
        }

        local TEMPLATE=/etc/kubernetes/manifests/kube-proxy.yaml
        [ -f $TEMPLATE ] || {
            echo "TEMPLATE: $TEMPLATE"
            mkdir -p $(dirname $TEMPLATE)
            cat << EOF > $TEMPLATE
    apiVersion: v1
    kind: Pod
    metadata:
      name: kube-proxy
      namespace: kube-system
    spec:
      hostNetwork: true
      containers:
      - name: kube-proxy
        image: gcr.io/google_containers/hyperkube:$K8S_VER
        command:
        - /hyperkube
        - proxy
        - --master=http://127.0.0.1:8080
        securityContext:
          privileged: true
        volumeMounts:
          - mountPath: /etc/ssl/certs
            name: "ssl-certs"
      volumes:
        - name: "ssl-certs"
          hostPath:
            path: "/usr/share/ca-certificates"
    EOF
        }

        local TEMPLATE=/etc/kubernetes/manifests/kube-apiserver.yaml
        [ -f $TEMPLATE ] || {
            echo "TEMPLATE: $TEMPLATE"
            mkdir -p $(dirname $TEMPLATE)
            cat << EOF > $TEMPLATE
    apiVersion: v1
    kind: Pod
    metadata:
      name: kube-apiserver
      namespace: kube-system
    spec:
      hostNetwork: true
      containers:
      - name: kube-apiserver
        image: gcr.io/google_containers/hyperkube:$K8S_VER
        command:
        - /hyperkube
        - apiserver
        - --bind-address=0.0.0.0
        - --etcd_servers=${ETCD_ENDPOINTS}
        - --allow-privileged=true
        - --service-cluster-ip-range=${SERVICE_IP_RANGE}
        - --secure_port=443
        - --advertise-address=${ADVERTISE_IP}
        - --admission-control=NamespaceLifecycle,NamespaceExists,LimitRanger,SecurityContextDeny,ServiceAccount,ResourceQuota
        - --tls-cert-file=/etc/kubernetes/ssl/apiserver.pem
        - --tls-private-key-file=/etc/kubernetes/ssl/apiserver-key.pem
        - --client-ca-file=/etc/kubernetes/ssl/ca.pem
        - --service-account-key-file=/etc/kubernetes/ssl/apiserver-key.pem
        ports:
        - containerPort: 443
          hostPort: 443
          name: https
        - containerPort: 7080
          hostPort: 7080
          name: http
        - containerPort: 8080
          hostPort: 8080
          name: local
        volumeMounts:
        - mountPath: /etc/kubernetes/ssl
          name: etckubessl
          readOnly: true
        - mountPath: /etc/ssl
          name: etcssl
          readOnly: true
        - mountPath: /var/ssl
          name: varssl
          readOnly: true
        - mountPath: /etc/openssl
          name: etcopenssl
          readOnly: true
        - mountPath: /etc/pki/tls
          name: etcpkitls
          readOnly: true
      volumes:
      - name: etckubessl
        hostPath:
          path: /etc/kubernetes/ssl
      - hostPath:
          path: /etc/ssl
        name: etcssl
      - hostPath:
          path: /var/ssl
        name: varssl
      - hostPath:
          path: /etc/openssl
        name: etcopenssl
      - hostPath:
          path: /etc/pki/tls
        name: etcpkitls
    EOF
        }

        local TEMPLATE=/etc/kubernetes/manifests/kube-podmaster.yaml
        [ -f $TEMPLATE ] || {
            echo "TEMPLATE: $TEMPLATE"
            mkdir -p $(dirname $TEMPLATE)
            cat << EOF > $TEMPLATE
    apiVersion: v1
    kind: Pod
    metadata:
      name: kube-podmaster
      namespace: kube-system
    spec:
      hostNetwork: true
      containers:
      - name: scheduler-elector
        image: gcr.io/google_containers/podmaster:1.1
        command:
        - /podmaster
        - --etcd-servers=${ETCD_ENDPOINTS}
        - --key=scheduler
        - --whoami=${ADVERTISE_IP}
        - --source-file=/src/manifests/kube-scheduler.yaml
        - --dest-file=/dst/manifests/kube-scheduler.yaml
        volumeMounts:
        - mountPath: /src/manifests
          name: manifest-src
          readOnly: true
        - mountPath: /dst/manifests
          name: manifest-dst
      - name: controller-manager-elector
        image: gcr.io/google_containers/podmaster:1.1
        command:
        - /podmaster
        - --etcd-servers=${ETCD_ENDPOINTS}
        - --key=controller
        - --whoami=${ADVERTISE_IP}
        - --source-file=/src/manifests/kube-controller-manager.yaml
        - --dest-file=/dst/manifests/kube-controller-manager.yaml
        terminationMessagePath: /dev/termination-log
        volumeMounts:
        - mountPath: /src/manifests
          name: manifest-src
          readOnly: true
        - mountPath: /dst/manifests
          name: manifest-dst
      volumes:
      - hostPath:
          path: /srv/kubernetes/manifests
        name: manifest-src
      - hostPath:
          path: /etc/kubernetes/manifests
        name: manifest-dst
    EOF
        }

        local TEMPLATE=/srv/kubernetes/manifests/kube-controller-manager.yaml
        [ -f $TEMPLATE ] || {
            echo "TEMPLATE: $TEMPLATE"
            mkdir -p $(dirname $TEMPLATE)
            cat << EOF > $TEMPLATE
    apiVersion: v1
    kind: Pod
    metadata:
      name: kube-controller-manager
      namespace: kube-system
    spec:
      containers:
      - name: kube-controller-manager
        image: gcr.io/google_containers/hyperkube:$K8S_VER
        command:
        - /hyperkube
        - controller-manager
        - --master=http://127.0.0.1:8080
        - --service-account-private-key-file=/etc/kubernetes/ssl/apiserver-key.pem
        - --root-ca-file=/etc/kubernetes/ssl/ca.pem
        livenessProbe:
          httpGet:
            host: 127.0.0.1
            path: /healthz
            port: 10252
          initialDelaySeconds: 15
          timeoutSeconds: 1
        volumeMounts:
        - mountPath: /etc/kubernetes/ssl
          name: etckubessl
          readOnly: true
        - mountPath: /etc/ssl
          name: etcssl
          readOnly: true
        - mountPath: /var/ssl
          name: varssl
          readOnly: true
        - mountPath: /etc/openssl
          name: etcopenssl
          readOnly: true
        - mountPath: /etc/pki/tls
          name: etcpkitls
          readOnly: true
      hostNetwork: true
      volumes:
      - name: etckubessl
        hostPath:
          path: /etc/kubernetes/ssl
      - hostPath:
          path: /etc/ssl
        name: etcssl
      - hostPath:
          path: /var/ssl
        name: varssl
      - hostPath:
          path: /etc/openssl
        name: etcopenssl
      - hostPath:
          path: /etc/pki/tls
        name: etcpkitls
    EOF
        }

        local TEMPLATE=/srv/kubernetes/manifests/kube-scheduler.yaml
        [ -f $TEMPLATE ] || {
            echo "TEMPLATE: $TEMPLATE"
            mkdir -p $(dirname $TEMPLATE)
            cat << EOF > $TEMPLATE
    apiVersion: v1
    kind: Pod
    metadata:
      name: kube-scheduler
      namespace: kube-system
    spec:
      hostNetwork: true
      containers:
      - name: kube-scheduler
        image: gcr.io/google_containers/hyperkube:$K8S_VER
        command:
        - /hyperkube
        - scheduler
        - --master=http://127.0.0.1:8080
        livenessProbe:
          httpGet:
            host: 127.0.0.1
            path: /healthz
            port: 10251
          initialDelaySeconds: 15
          timeoutSeconds: 1
    EOF
        }



        local TEMPLATE=/srv/kubernetes/manifests/kube-system.json
        [ -f $TEMPLATE ] || {
            echo "TEMPLATE: $TEMPLATE"
            mkdir -p $(dirname $TEMPLATE)
            cat << EOF > $TEMPLATE
    {
      "apiVersion": "v1",
      "kind": "Namespace",
      "metadata": {
        "name": "kube-system"
      }
    }
    EOF
        }

        local TEMPLATE=/srv/kubernetes/manifests/kube-dns-rc.json
        [ -f $TEMPLATE ] || {
            echo "TEMPLATE: $TEMPLATE"
            mkdir -p $(dirname $TEMPLATE)
            cat << EOF > $TEMPLATE
    {
        "apiVersion": "v1",
        "kind": "ReplicationController",
        "metadata": {
            "labels": {
                "k8s-app": "kube-dns",
                "kubernetes.io/cluster-service": "true",
                "version": "v9"
            },
            "name": "kube-dns-v9",
            "namespace": "kube-system"
        },
        "spec": {
            "replicas": 1,
            "selector": {
                "k8s-app": "kube-dns",
                "version": "v9"
            },
            "template": {
                "metadata": {
                    "labels": {
                        "k8s-app": "kube-dns",
                        "kubernetes.io/cluster-service": "true",
                        "version": "v9"
                    }
                },
                "spec": {
                    "containers": [
                        {
                            "command": [
                                "/usr/local/bin/etcd",
                                "-data-dir",
                                "/var/etcd/data",
                                "-listen-client-urls",
                                "http://127.0.0.1:2379,http://127.0.0.1:4001",
                                "-advertise-client-urls",
                                "http://127.0.0.1:2379,http://127.0.0.1:4001",
                                "-initial-cluster-token",
                                "skydns-etcd"
                            ],
                            "image": "gcr.io/google_containers/etcd:2.0.9",
                            "name": "etcd",
                            "resources": {
                                "limits": {
                                    "cpu": "100m",
                                    "memory": "50Mi"
                                }
                            },
                            "volumeMounts": [
                                {
                                    "mountPath": "/var/etcd/data",
                                    "name": "etcd-storage"
                                }
                            ]
                        },
                        {
                            "args": [
                                "-domain=cluster.local"
                            ],
                            "image": "gcr.io/google_containers/kube2sky:1.11",
                            "name": "kube2sky",
                            "resources": {
                                "limits": {
                                    "cpu": "100m",
                                    "memory": "50Mi"
                                }
                            }
                        },
                        {
                            "args": [
                                "-machines=http://localhost:4001",
                                "-addr=0.0.0.0:53",
                                "-domain=cluster.local."
                            ],
                            "image": "gcr.io/google_containers/skydns:2015-03-11-001",
                            "livenessProbe": {
                                "httpGet": {
                                    "path": "/healthz",
                                    "port": 8080,
                                    "scheme": "HTTP"
                                },
                                "initialDelaySeconds": 30,
                                "timeoutSeconds": 5
                            },
                            "name": "skydns",
                            "ports": [
                                {
                                    "containerPort": 53,
                                    "name": "dns",
                                    "protocol": "UDP"
                                },
                                {
                                    "containerPort": 53,
                                    "name": "dns-tcp",
                                    "protocol": "TCP"
                                }
                            ],
                            "readinessProbe": {
                                "httpGet": {
                                    "path": "/healthz",
                                    "port": 8080,
                                    "scheme": "HTTP"
                                },
                                "initialDelaySeconds": 1,
                                "timeoutSeconds": 5
                            },
                            "resources": {
                                "limits": {
                                    "cpu": "100m",
                                    "memory": "50Mi"
                                }
                            }
                        },
                        {
                            "args": [
                                "-cmd=nslookup kubernetes.default.svc.cluster.local localhost >/dev/null",
                                "-port=8080"
                            ],
                            "image": "gcr.io/google_containers/exechealthz:1.0",
                            "name": "healthz",
                            "ports": [
                                {
                                    "containerPort": 8080,
                                    "protocol": "TCP"
                                }
                            ],
                            "resources": {
                                "limits": {
                                    "cpu": "10m",
                                    "memory": "20Mi"
                                }
                            }
                        }
                    ],
                    "dnsPolicy": "Default",
                    "volumes": [
                        {
                            "emptyDir": {},
                            "name": "etcd-storage"
                        }
                    ]
                }
            }
        }
    }
    EOF
        }

        local TEMPLATE=/srv/kubernetes/manifests/kube-dns-svc.json
        [ -f $TEMPLATE ] || {
            echo "TEMPLATE: $TEMPLATE"
            mkdir -p $(dirname $TEMPLATE)
            cat << EOF > $TEMPLATE
    {
      "apiVersion": "v1",
      "kind": "Service",
      "metadata": {
        "name": "kube-dns",
        "namespace": "kube-system",
        "labels": {
          "k8s-app": "kube-dns",
          "kubernetes.io/name": "KubeDNS",
          "kubernetes.io/cluster-service": "true"
        }
      },
      "spec": {
        "clusterIP": "$DNS_SERVICE_IP",
        "ports": [
          {
            "protocol": "UDP",
            "name": "dns",
            "port": 53
          },
          {
            "protocol": "TCP",
            "name": "dns-tcp",
            "port": 53
          }
        ],
        "selector": {
          "k8s-app": "kube-dns"
        }
      }
    }
    EOF
        }

    }

    function start_addons {
        echo "Waiting for Kubernetes API..."
        until curl --silent "http://127.0.0.1:8080/version"
        do
            sleep 5
        done
        echo
        echo "K8S: kube-system namespace"
        curl --silent -XPOST -d"$(cat /srv/kubernetes/manifests/kube-system.json)" "http://127.0.0.1:8080/api/v1/namespaces" > /dev/null
        echo "K8S: DNS addon"
        curl --silent -XPOST -d"$(cat /srv/kubernetes/manifests/kube-dns-rc.json)" "http://127.0.0.1:8080/api/v1/namespaces/kube-system/replicationcontrollers" > /dev/null
        curl --silent -XPOST -d"$(cat /srv/kubernetes/manifests/kube-dns-svc.json)" "http://127.0.0.1:8080/api/v1/namespaces/kube-system/services" > /dev/null
    }

    if [ "$CMD" == "init" ]; then
        echo "Starting initialization"
        init_config
        init_flannel
        init_docker
        init_templates
        echo "Initialization complete"
        exit 0
    fi

    if [ "$CMD" == "start" ]; then
        echo "Starting services"
        systemctl daemon-reload
        systemctl enable kubelet; systemctl start kubelet
        start_addons
        echo "Service start complete"
        exit 0
    fi

    usage
    exit 1
